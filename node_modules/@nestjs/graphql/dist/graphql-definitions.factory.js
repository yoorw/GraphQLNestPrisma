"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const shared_utils_1 = require("@nestjs/common/utils/shared.utils");
const apollo_server_express_1 = require("apollo-server-express");
const chokidar = require("chokidar");
const graphql_1 = require("graphql");
const graphql_ast_explorer_1 = require("./graphql-ast.explorer");
const graphql_types_loader_1 = require("./graphql-types.loader");
class GraphQLDefinitionsFactory {
    constructor() {
        this.gqlAstExplorer = new graphql_ast_explorer_1.GraphQLAstExplorer();
        this.gqlTypesLoader = new graphql_types_loader_1.GraphQLTypesLoader();
    }
    generate(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const typePathsExists = options.typePaths && !shared_utils_1.isEmpty(options.typePaths);
            if (!typePathsExists) {
                throw new Error(`"typePaths" property cannot be empty.`);
            }
            if (options.watch) {
                console.log('GraphQL factory is watching your files...');
                const watcher = chokidar.watch(options.typePaths);
                watcher.on('change', (file) => __awaiter(this, void 0, void 0, function* () {
                    console.log(`[${new Date().toLocaleTimeString()}] "${file}" has been changed.`);
                    yield this.exploreAndEmit(options.typePaths, options.path, options.outputAs);
                }));
            }
            yield this.exploreAndEmit(options.typePaths, options.path, options.outputAs);
        });
    }
    exploreAndEmit(typePaths, path, outputAs) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeDefs = this.gqlTypesLoader.mergeTypesByPaths(...(typePaths || []));
            let schema = apollo_server_express_1.makeExecutableSchema({
                typeDefs,
                resolverValidationOptions: { allowResolversNotInSchema: true },
            });
            schema = graphql_1.printSchema(schema);
            const tsFile = this.gqlAstExplorer.explore(apollo_server_express_1.gql `
        ${schema}
      `, path, outputAs);
            yield tsFile.save();
            console.log(`[${new Date().toLocaleTimeString()}] The definitions have been updated.`);
        });
    }
}
exports.GraphQLDefinitionsFactory = GraphQLDefinitionsFactory;
